/**
 * Open source software under the terms in /LICENSE
 * Copyright (c) 2021-2024, Carnegie Mellon University. All rights reserved.
 */

// CAUTION: This file is autogenerated from https://github.com/arenaxr/arena-schemas. Changes made here may be overwritten.

using System;
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using UnityEngine;

namespace ArenaUnity.Schemas
{
    /// <summary>
    /// Controls physics properties for individual shapes or rigid bodies. Can be set on an entity with physx-body or on shapes contained within it. Requires `scene-options: physics`.
    /// </summary>
    [Serializable]
    public class ArenaPhysxMaterialJson
    {
        [JsonIgnore]
        public readonly string componentName = "physx-material";

        // physx-material member-fields

        private static float defStaticFriction = 0.2f;
        [JsonProperty(PropertyName = "staticFriction")]
        [Tooltip("Static friction applied when objects are not moving relative to each other.")]
        public float StaticFriction = defStaticFriction;
        public bool ShouldSerializeStaticFriction()
        {
            // staticFriction
            return (StaticFriction != defStaticFriction);
        }

        private static float defDynamicFriction = 0.2f;
        [JsonProperty(PropertyName = "dynamicFriction")]
        [Tooltip("Dynamic friction applied when objects are moving relative to each other.")]
        public float DynamicFriction = defDynamicFriction;
        public bool ShouldSerializeDynamicFriction()
        {
            // dynamicFriction
            return (DynamicFriction != defDynamicFriction);
        }

        private static float defRestitution = 0.2f;
        [JsonProperty(PropertyName = "restitution")]
        [Tooltip("Restitution, or 'bounciness' of the material.")]
        public float Restitution = defRestitution;
        public bool ShouldSerializeRestitution()
        {
            // restitution
            return (Restitution != defRestitution);
        }

        private static float? defDensity = null;
        [JsonProperty(PropertyName = "density")]
        [Tooltip("Density for the shape. If specified for all shapes in a rigid body, mass properties will be automatically calculated based on densities.")]
        public float? Density = defDensity;
        public bool ShouldSerializeDensity()
        {
            // density
            return (Density != defDensity);
        }

        private static float?[] defCollisionLayers = { 1f };
        [JsonProperty(PropertyName = "collisionLayers")]
        [Tooltip("Which collision layers this shape is present on.")]
        public float?[] CollisionLayers = defCollisionLayers;
        public bool ShouldSerializeCollisionLayers()
        {
            // collisionLayers
            return (CollisionLayers != defCollisionLayers);
        }

        private static float?[] defCollidesWithLayers = { 1f, 2f, 3f, 4f };
        [JsonProperty(PropertyName = "collidesWithLayers")]
        [Tooltip("Array containing all layers that this shape should collide with.")]
        public float?[] CollidesWithLayers = defCollidesWithLayers;
        public bool ShouldSerializeCollidesWithLayers()
        {
            // collidesWithLayers
            return (CollidesWithLayers != defCollidesWithLayers);
        }

        private static float defCollisionGroup = 0f;
        [JsonProperty(PropertyName = "collisionGroup")]
        [Tooltip("If greater than 0, this shape will not collide with any other shape with the same collisionGroup value.")]
        public float CollisionGroup = defCollisionGroup;
        public bool ShouldSerializeCollisionGroup()
        {
            // collisionGroup
            return (CollisionGroup != defCollisionGroup);
        }

        private static string defContactOffset = null;
        [JsonProperty(PropertyName = "contactOffset")]
        [Tooltip("If >= 0, sets the PhysX contact offset, indicating how far away from the shape simulation contact events should begin.")]
        public string ContactOffset = defContactOffset;
        public bool ShouldSerializeContactOffset()
        {
            // contactOffset
            return (ContactOffset != defContactOffset);
        }

        private static string defRestOffset = null;
        [JsonProperty(PropertyName = "restOffset")]
        [Tooltip("If >= 0, sets the PhysX rest offset.")]
        public string RestOffset = defRestOffset;
        public bool ShouldSerializeRestOffset()
        {
            // restOffset
            return (RestOffset != defRestOffset);
        }

        // General json object management
        [OnError]
        internal void OnError(StreamingContext context, ErrorContext errorContext)
        {
            Debug.LogWarning($"{errorContext.Error.Message}: {errorContext.OriginalObject}");
            errorContext.Handled = true;
        }

        [JsonExtensionData]
        private IDictionary<string, JToken> _additionalData;
    }
}
