/**
 * Open source software under the terms in /LICENSE
 * Copyright (c) 2021-2024, Carnegie Mellon University. All rights reserved.
 */

// CAUTION: This file is autogenerated from https://github.com/arenaxr/arena-schemas. Changes made here may be overwritten.

using System;
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using UnityEngine;

namespace ArenaUnity.Schemas
{
    /// <summary>
    /// Creates a PhysX joint between an ancestor rigid body and a target rigid body. Position and rotation of the entity will be used to create the corresponding joint. Requires `scene-options: physics`.
    /// </summary>
    [Serializable]
    public class ArenaPhysxJointJson
    {
        [JsonIgnore]
        public readonly string componentName = "physx-joint";

        // physx-joint member-fields

        public enum TypeType
        {
            [EnumMember(Value = "Spherical")]
            Spherical,
            [EnumMember(Value = "Fixed")]
            Fixed,
            [EnumMember(Value = "Revolute")]
            Revolute,
            [EnumMember(Value = "Prismatic")]
            Prismatic,
            [EnumMember(Value = "D6")]
            D6,
        }
        private static TypeType defType = TypeType.Spherical;
        [JsonConverter(typeof(StringEnumConverter))]
        [JsonProperty(PropertyName = "type")]
        [Tooltip("Rigid body joint type to use. Each type has different movement constraints.")]
        public TypeType Type = defType;
        public bool ShouldSerializeType()
        {
            // type
            return (Type != defType);
        }

        private static string defTarget = null;
        [JsonProperty(PropertyName = "target")]
        [Tooltip("Target object selector. Must be an entity having the physx-body component. If not specified, joins to the initial position in the world.")]
        public string Target = defTarget;
        public bool ShouldSerializeTarget()
        {
            // target
            return (Target != defTarget);
        }

        private static ArenaVector2Json defBreakForce = JsonConvert.DeserializeObject<ArenaVector2Json>("{'x': -1, 'y': -1}");
        [JsonProperty(PropertyName = "breakForce")]
        [Tooltip("Force needed to break the constraint. First component is linear force, second is angular force in degrees. Set both components >= 0 to enable.")]
        public ArenaVector2Json BreakForce = defBreakForce;
        public bool ShouldSerializeBreakForce()
        {
            // breakForce
            return (BreakForce != defBreakForce);
        }

        private static bool defRemoveElOnBreak = false;
        [JsonProperty(PropertyName = "removeElOnBreak")]
        [Tooltip("If true, removes the entity containing this component when the joint is broken.")]
        public bool RemoveElOnBreak = defRemoveElOnBreak;
        public bool ShouldSerializeRemoveElOnBreak()
        {
            // removeElOnBreak
            return (RemoveElOnBreak != defRemoveElOnBreak);
        }

        private static bool defCollideWithTarget = false;
        [JsonProperty(PropertyName = "collideWithTarget")]
        [Tooltip("If false, collision will be disabled between the rigid body containing the joint and the target rigid body.")]
        public bool CollideWithTarget = defCollideWithTarget;
        public bool ShouldSerializeCollideWithTarget()
        {
            // collideWithTarget
            return (CollideWithTarget != defCollideWithTarget);
        }

        private static bool defSoftFixed = false;
        [JsonProperty(PropertyName = "softFixed")]
        [Tooltip("When used with a D6 type, sets up a 'soft' fixed joint. E.g., for grabbing things.")]
        public bool SoftFixed = defSoftFixed;
        public bool ShouldSerializeSoftFixed()
        {
            // softFixed
            return (SoftFixed != defSoftFixed);
        }

        private static ArenaVector2Json defProjectionTolerance = JsonConvert.DeserializeObject<ArenaVector2Json>("{'x': -1, 'y': -1}");
        [JsonProperty(PropertyName = "projectionTolerance")]
        [Tooltip("Kinematic projection, which forces joint back into alignment when the solver fails. First component is linear tolerance in meters, second is angular tolerance in degrees.")]
        public ArenaVector2Json ProjectionTolerance = defProjectionTolerance;
        public bool ShouldSerializeProjectionTolerance()
        {
            // projectionTolerance
            return (ProjectionTolerance != defProjectionTolerance);
        }

        // General json object management
        [OnError]
        internal void OnError(StreamingContext context, ErrorContext errorContext)
        {
            Debug.LogWarning($"{errorContext.Error.Message}: {errorContext.OriginalObject}");
            errorContext.Handled = true;
        }

        [JsonExtensionData]
        private IDictionary<string, JToken> _additionalData;
    }
}
