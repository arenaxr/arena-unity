/**
 * Open source software under the terms in /LICENSE
 * Copyright (c) 2021-2024, Carnegie Mellon University. All rights reserved.
 */

// CAUTION: This file is autogenerated from https://github.com/arenaxr/arena-schemas. Changes made here may be overwritten.

using System;
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using UnityEngine;

namespace ArenaUnity.Schemas
{
    /// <summary>
    /// Turns an entity into a PhysX rigid body. This is the main component for creating physics objects. There are 3 types of rigid bodies: dynamic objects that have physics simulated on them, static objects that cannot move, and kinematic objects that can be moved programmatically but not by simulation. Requires `scene-options: physics`.
    /// </summary>
    [Serializable]
    public class ArenaPhysxBodyJson
    {
        [JsonIgnore]
        public readonly string componentName = "physx-body";

        // physx-body member-fields

        public enum TypeType
        {
            [EnumMember(Value = "dynamic")]
            Dynamic,
            [EnumMember(Value = "static")]
            Static,
            [EnumMember(Value = "kinematic")]
            Kinematic,
        }
        private static TypeType defType = TypeType.Dynamic;
        [JsonConverter(typeof(StringEnumConverter))]
        [JsonProperty(PropertyName = "type")]
        [Tooltip("Type of the rigid body to create. Dynamic can be moved by physics, Static cannot be moved, Kinematic can be moved programmatically.")]
        public TypeType Type = defType;
        public bool ShouldSerializeType()
        {
            // type
            return (Type != defType);
        }

        private static float defMass = 1f;
        [JsonProperty(PropertyName = "mass")]
        [Tooltip("Total mass of the body.")]
        public float Mass = defMass;
        public bool ShouldSerializeMass()
        {
            // mass
            return (Mass != defMass);
        }

        private static float defAngularDamping = 0f;
        [JsonProperty(PropertyName = "angularDamping")]
        [Tooltip("If > 0, will set the rigid body's angular damping to reduce rotation over time.")]
        public float AngularDamping = defAngularDamping;
        public bool ShouldSerializeAngularDamping()
        {
            // angularDamping
            return (AngularDamping != defAngularDamping);
        }

        private static float defLinearDamping = 0f;
        [JsonProperty(PropertyName = "linearDamping")]
        [Tooltip("If > 0, will set the rigid body's linear damping to reduce movement over time.")]
        public float LinearDamping = defLinearDamping;
        public bool ShouldSerializeLinearDamping()
        {
            // linearDamping
            return (LinearDamping != defLinearDamping);
        }

        private static bool defEmitCollisionEvents = false;
        [JsonProperty(PropertyName = "emitCollisionEvents")]
        [Tooltip("If set to true, it will emit 'contactbegin' and 'contactend' events when collisions occur.")]
        public bool EmitCollisionEvents = defEmitCollisionEvents;
        public bool ShouldSerializeEmitCollisionEvents()
        {
            // emitCollisionEvents
            return (EmitCollisionEvents != defEmitCollisionEvents);
        }

        private static bool defHighPrecision = false;
        [JsonProperty(PropertyName = "highPrecision")]
        [Tooltip("If set to true, the object will receive extra attention by the simulation engine (at a performance cost).")]
        public bool HighPrecision = defHighPrecision;
        public bool ShouldSerializeHighPrecision()
        {
            // highPrecision
            return (HighPrecision != defHighPrecision);
        }

        private static ArenaVector3Json defShapeOffset = JsonConvert.DeserializeObject<ArenaVector3Json>("{'x': 0, 'y': 0, 'z': 0}");
        [JsonProperty(PropertyName = "shapeOffset")]
        [Tooltip("Offset applied to generated collision shapes.")]
        public ArenaVector3Json ShapeOffset = defShapeOffset;
        public bool ShouldSerializeShapeOffset()
        {
            // shapeOffset
            return (ShapeOffset != defShapeOffset);
        }

        // General json object management
        [OnError]
        internal void OnError(StreamingContext context, ErrorContext errorContext)
        {
            Debug.LogWarning($"{errorContext.Error.Message}: {errorContext.OriginalObject}");
            errorContext.Handled = true;
        }

        [JsonExtensionData]
        private IDictionary<string, JToken> _additionalData;
    }
}
