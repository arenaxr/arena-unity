/**
 * Open source software under the terms in /LICENSE
 * Copyright (c) 2021-2024, Carnegie Mellon University. All rights reserved.
 */

// CAUTION: This file is autogenerated from https://github.com/arenaxr/arena-schemas. Changes made here may be overwritten.

using System;
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using UnityEngine;

namespace ArenaUnity.Schemas
{
    /// <summary>
    /// Wraps all attributes in JSON.
    /// </summary>
    [Serializable]
    public class ArenaDataJson
    {
        [JsonIgnore]
        public readonly string componentName = "data";

        // data member-fields

        [JsonProperty(PropertyName = "object_type")]
        [Tooltip("3D object type.")]
        public string object_type = null;
        public bool ShouldSerializeobject_type()
        {
            return (object_type != null);
        }

        private static string defParent = null;
        [JsonProperty(PropertyName = "parent")]
        [Tooltip("Parent's object_id. Child objects inherit attributes of their parent, for example scale and translation.")]
        public string Parent = defParent;
        public bool ShouldSerializeParent()
        {
            // parent
            return (Parent != defParent);
        }

        private static ArenaVector3Json defPosition = null;
        [JsonProperty(PropertyName = "position")]
        [Tooltip("3D object position.")]
        public ArenaVector3Json Position = defPosition;
        public bool ShouldSerializePosition()
        {
            // position
            return (Position != defPosition);
        }

        private static ArenaRotationJson defRotation = null;
        [JsonProperty(PropertyName = "rotation")]
        [Tooltip("3D object rotation in quaternion representation; Right-handed coordinate system. Euler degrees are deprecated in wire message format.")]
        public ArenaRotationJson Rotation = defRotation;
        public bool ShouldSerializeRotation()
        {
            // rotation
            return (Rotation != defRotation);
        }

        private static ArenaVector3Json defScale = null;
        [JsonProperty(PropertyName = "scale")]
        [Tooltip("3D object scale.")]
        public ArenaVector3Json Scale = defScale;
        public bool ShouldSerializeScale()
        {
            // scale
            return (Scale != defScale);
        }

        private static bool defVisible = true;
        [JsonProperty(PropertyName = "visible")]
        [Tooltip("Whether object is visible. Property is inherited.")]
        public bool Visible = defVisible;
        public bool ShouldSerializeVisible()
        {
            // visible
            return (Visible != defVisible);
        }

        private static ArenaAnimationJson defAnimation = null;
        [JsonProperty(PropertyName = "animation")]
        [Tooltip("Animate and tween values. More properties at <a href='https://aframe.io/docs/1.5.0/components/animation.html'>A-Frame Animation</a> component. Easing properties are detailed at <a href='https://easings.net'>easings.net</a>.")]
        public ArenaAnimationJson Animation = defAnimation;
        public bool ShouldSerializeAnimation()
        {
            // animation
            return (Animation != defAnimation);
        }

        private static ArenaArmarkerJson defArmarker = null;
        [JsonProperty(PropertyName = "armarker")]
        [Tooltip("A location marker (such as an AprilTag, a lightAnchor, or an UWB tag), used to anchor scenes, or scene objects, in the real world.")]
        public ArenaArmarkerJson Armarker = defArmarker;
        public bool ShouldSerializeArmarker()
        {
            // armarker
            return (Armarker != defArmarker);
        }

        private static ArenaClickListenerJson defClickListener = null;
        [JsonProperty(PropertyName = "click-listener")]
        [Tooltip("Object will listen for mouse events like clicks.")]
        public ArenaClickListenerJson ClickListener = defClickListener;
        public bool ShouldSerializeClickListener()
        {
            // click-listener
            return (ClickListener != defClickListener);
        }

        private static ArenaBoxCollisionListenerJson defBoxCollisionListener = null;
        [JsonProperty(PropertyName = "box-collision-listener")]
        [Tooltip("Listen for bounding-box collisions with user camera and hands. Must be applied to an object or model with geometric mesh. Collisions are determined by course bounding-box overlaps.")]
        public ArenaBoxCollisionListenerJson BoxCollisionListener = defBoxCollisionListener;
        public bool ShouldSerializeBoxCollisionListener()
        {
            // box-collision-listener
            return (BoxCollisionListener != defBoxCollisionListener);
        }

        private static string defCollisionListener = null;
        [JsonProperty(PropertyName = "collision-listener")]
        [Tooltip("Name of the collision-listener, default can be empty string. Collisions trigger click events. Requires `scene-options: physics`.")]
        public string CollisionListener = defCollisionListener;
        public bool ShouldSerializeCollisionListener()
        {
            // collision-listener
            return (CollisionListener != defCollisionListener);
        }

        private static ArenaBlipJson defBlip = null;
        [JsonProperty(PropertyName = "blip")]
        [Tooltip("When the object is created or deleted, it will animate in/out of the scene instead of appearing/disappearing instantly. Must have a geometric mesh.")]
        public ArenaBlipJson Blip = defBlip;
        public bool ShouldSerializeBlip()
        {
            // blip
            return (Blip != defBlip);
        }

        private static ArenaDynamicBodyJson defDynamicBody = null;
        [JsonProperty(PropertyName = "dynamic-body")]
        [Obsolete("DEPRECATED: data.dynamic-body is deprecated, use data.physx-body instead.")]
        public ArenaDynamicBodyJson DynamicBody { get; protected set; } = defDynamicBody;
        public bool ShouldSerializeDynamicBody()
        {
            return false; // deprecated in json schema
        }

        private static ArenaStaticBodyJson defStaticBody = null;
        [JsonProperty(PropertyName = "static-body")]
        [Obsolete("DEPRECATED: data.static-body is deprecated, use data.physx-body instead.")]
        public ArenaStaticBodyJson StaticBody { get; protected set; } = defStaticBody;
        public bool ShouldSerializeStaticBody()
        {
            return false; // deprecated in json schema
        }

        private static ArenaPhysxBodyJson defPhysxBody = null;
        [JsonProperty(PropertyName = "physx-body")]
        [Tooltip("Turns an entity into a PhysX rigid body. This is the main component for creating physics objects. There are 3 types of rigid bodies: dynamic objects that have physics simulated on them, static objects that cannot move, and kinematic objects that can be moved programmatically but not by simulation. Requires `scene-options: physics`.")]
        public ArenaPhysxBodyJson PhysxBody = defPhysxBody;
        public bool ShouldSerializePhysxBody()
        {
            // physx-body
            return (PhysxBody != defPhysxBody);
        }

        private static ArenaPhysxMaterialJson defPhysxMaterial = null;
        [JsonProperty(PropertyName = "physx-material")]
        [Tooltip("Controls physics properties for individual shapes or rigid bodies. Can be set on an entity with physx-body or on shapes contained within it. Requires `scene-options: physics`.")]
        public ArenaPhysxMaterialJson PhysxMaterial = defPhysxMaterial;
        public bool ShouldSerializePhysxMaterial()
        {
            // physx-material
            return (PhysxMaterial != defPhysxMaterial);
        }

        private static ArenaPhysxJointJson defPhysxJoint = null;
        [JsonProperty(PropertyName = "physx-joint")]
        [Tooltip("Creates a PhysX joint between an ancestor rigid body and a target rigid body. Position and rotation of the entity will be used to create the corresponding joint. Requires `scene-options: physics`.")]
        public ArenaPhysxJointJson PhysxJoint = defPhysxJoint;
        public bool ShouldSerializePhysxJoint()
        {
            // physx-joint
            return (PhysxJoint != defPhysxJoint);
        }

        private static ArenaPhysxJointConstraintJson defPhysxJointConstraint = null;
        [JsonProperty(PropertyName = "physx-joint-constraint")]
        [Tooltip("Adds a constraint to a physx-joint. Supported joints are D6, Revolute and Prismatic. Can only be used on an entity with the physx-joint component. Requires `scene-options: physics`.")]
        public ArenaPhysxJointConstraintJson PhysxJointConstraint = defPhysxJointConstraint;
        public bool ShouldSerializePhysxJointConstraint()
        {
            // physx-joint-constraint
            return (PhysxJointConstraint != defPhysxJointConstraint);
        }

        private static ArenaPhysxJointDriverJson defPhysxJointDriver = null;
        [JsonProperty(PropertyName = "physx-joint-driver")]
        [Tooltip("Creates a driver which exerts force to return the joint to the initial position with the given velocity characteristics. Can only be used on an entity with a physx-joint component. Currently only supports D6 joint type. Requires `scene-options: physics`.")]
        public ArenaPhysxJointDriverJson PhysxJointDriver = defPhysxJointDriver;
        public bool ShouldSerializePhysxJointDriver()
        {
            // physx-joint-driver
            return (PhysxJointDriver != defPhysxJointDriver);
        }

        private static ArenaPhysxForcePushableJson defPhysxForcePushable = null;
        [JsonProperty(PropertyName = "physx-force-pushable")]
        [Tooltip("Makes a physx-body object pushable by the user. Requires `click-listener` attribute. Requires `scene-options: physics`.")]
        public ArenaPhysxForcePushableJson PhysxForcePushable = defPhysxForcePushable;
        public bool ShouldSerializePhysxForcePushable()
        {
            // physx-force-pushable
            return (PhysxForcePushable != defPhysxForcePushable);
        }

        private static bool defPhysxGrabbable = true;
        [JsonProperty(PropertyName = "physx-grabbable")]
        [Tooltip("Makes a physx-body object grabbable by the user's hands. Requires `scene-options: physics`.")]
        public bool PhysxGrabbable = defPhysxGrabbable;
        public bool ShouldSerializePhysxGrabbable()
        {
            // physx-grabbable
            return (PhysxGrabbable != defPhysxGrabbable);
        }

        private static ArenaGotoLandmarkJson defGotoLandmark = null;
        [JsonProperty(PropertyName = "goto-landmark")]
        [Tooltip("Teleports user to the landmark with the given name. Requires `click-listener` attribute.")]
        public ArenaGotoLandmarkJson GotoLandmark = defGotoLandmark;
        public bool ShouldSerializeGotoLandmark()
        {
            // goto-landmark
            return (GotoLandmark != defGotoLandmark);
        }

        private static ArenaGotoUrlJson defGotoUrl = null;
        [JsonProperty(PropertyName = "goto-url")]
        [Tooltip("Load new URL when object is clicked. Requires `click-listener` attribute.")]
        public ArenaGotoUrlJson GotoUrl = defGotoUrl;
        public bool ShouldSerializeGotoUrl()
        {
            // goto-url
            return (GotoUrl != defGotoUrl);
        }

        private static bool? defHideOnEnterAr = null;
        [JsonProperty(PropertyName = "hide-on-enter-ar")]
        [Tooltip("Hide object when entering AR. Remove component to *not* hide.")]
        public bool? HideOnEnterAr = defHideOnEnterAr;
        public bool ShouldSerializeHideOnEnterAr()
        {
            // hide-on-enter-ar
            return (HideOnEnterAr != defHideOnEnterAr);
        }

        private static bool? defHideOnEnterVr = null;
        [JsonProperty(PropertyName = "hide-on-enter-vr")]
        [Tooltip("Hide object when entering VR. Remove component to *not* hide.")]
        public bool? HideOnEnterVr = defHideOnEnterVr;
        public bool ShouldSerializeHideOnEnterVr()
        {
            // hide-on-enter-vr
            return (HideOnEnterVr != defHideOnEnterVr);
        }

        private static bool? defShowOnEnterAr = null;
        [JsonProperty(PropertyName = "show-on-enter-ar")]
        [Tooltip("Show object when entering AR. Hidden otherwise.")]
        public bool? ShowOnEnterAr = defShowOnEnterAr;
        public bool ShouldSerializeShowOnEnterAr()
        {
            // show-on-enter-ar
            return (ShowOnEnterAr != defShowOnEnterAr);
        }

        private static bool? defShowOnEnterVr = null;
        [JsonProperty(PropertyName = "show-on-enter-vr")]
        [Tooltip("Show object when entering VR. Hidden otherwise.")]
        public bool? ShowOnEnterVr = defShowOnEnterVr;
        public bool ShouldSerializeShowOnEnterVr()
        {
            // show-on-enter-vr
            return (ShowOnEnterVr != defShowOnEnterVr);
        }

        private static ArenaImpulseJson defImpulse = null;
        [JsonProperty(PropertyName = "impulse")]
        [Obsolete("DEPRECATED: data.impulse is deprecated, use data.physx-force-pushable instead.")]
        public ArenaImpulseJson Impulse { get; protected set; } = defImpulse;
        public bool ShouldSerializeImpulse()
        {
            return false; // deprecated in json schema
        }

        private static ArenaLandmarkJson defLandmark = null;
        [JsonProperty(PropertyName = "landmark")]
        [Tooltip("Define entities as a landmark; Landmarks appears in the landmark list and you can move (teleport) to them; You can define the behavior of the teleport: if you will be at a fixed or random distance, looking at the landmark, fixed offset or if it is constrained by a navmesh (when it exists).")]
        public ArenaLandmarkJson Landmark = defLandmark;
        public bool ShouldSerializeLandmark()
        {
            // landmark
            return (Landmark != defLandmark);
        }

        private static ArenaMaterialExtrasJson defMaterialExtras = null;
        [JsonProperty(PropertyName = "material-extras")]
        [Tooltip("Define extra material properties, namely texture encoding, whether to render the material's color and render order. Requires `material` attribute. More properties at <a href='https://threejs.org/docs/#api/en/materials/Material'>THREE.js Material</a>.")]
        public ArenaMaterialExtrasJson MaterialExtras = defMaterialExtras;
        public bool ShouldSerializeMaterialExtras()
        {
            // material-extras
            return (MaterialExtras != defMaterialExtras);
        }

        private static ArenaModelContainerJson defModelContainer = null;
        [JsonProperty(PropertyName = "model-container")]
        [Tooltip("Overrides absolute size for a 3D model. The model can be a glTF, glb, obj, or any other supported format. The model will be rescaled to fit to the sizes specified for each axes.")]
        public ArenaModelContainerJson ModelContainer = defModelContainer;
        public bool ShouldSerializeModelContainer()
        {
            // model-container
            return (ModelContainer != defModelContainer);
        }

        private static ArenaShadowJson defShadow = null;
        [JsonProperty(PropertyName = "shadow")]
        [Tooltip("The shadow component enables shadows for an entity and its children. Adding the shadow component alone is not enough to display shadows in your scene. We must have at least one light with castShadow: true enabled.")]
        public ArenaShadowJson Shadow = defShadow;
        public bool ShouldSerializeShadow()
        {
            // shadow
            return (Shadow != defShadow);
        }

        private static ArenaSoundJson defSound = null;
        [JsonProperty(PropertyName = "sound")]
        [Tooltip("The sound component defines the entity as a source of sound or audio. The sound component can be positional and is thus affected by the component's position. More properties at <a href='https://aframe.io/docs/1.5.0/components/sound.html'>A-Frame Sound</a>.")]
        public ArenaSoundJson Sound = defSound;
        public bool ShouldSerializeSound()
        {
            // sound
            return (Sound != defSound);
        }

        private static string defSubmodelParent = "";
        [JsonProperty(PropertyName = "submodel-parent")]
        [Tooltip("When this object is parented to a hierarchical model, it attaches to a named sub-component of that model instead of the root position. Requires `parent` attribute.")]
        public string SubmodelParent = defSubmodelParent;
        public bool ShouldSerializeSubmodelParent()
        {
            // submodel-parent
            return (SubmodelParent != defSubmodelParent);
        }

        private static ArenaTextinputJson defTextinput = null;
        [JsonProperty(PropertyName = "textinput")]
        [Tooltip("Opens an HTML prompt when clicked. Sends text input as an event on MQTT. Requires `click-listener` attribute.")]
        public ArenaTextinputJson Textinput = defTextinput;
        public bool ShouldSerializeTextinput()
        {
            // textinput
            return (Textinput != defTextinput);
        }

        private static string defUrl = null;
        [JsonProperty(PropertyName = "url")]
        [Tooltip("Use File Store paths under 'store/users/username', see CDN and other storage options in the description above.")]
        public string Url = defUrl;
        public bool ShouldSerializeUrl()
        {
            // url
            return (Url != defUrl);
        }

        private static ArenaRemoteRenderJson defRemoteRender = null;
        [JsonProperty(PropertyName = "remote-render")]
        [Tooltip("Whether or not an object should be remote rendered [Experimental].")]
        public ArenaRemoteRenderJson RemoteRender = defRemoteRender;
        public bool ShouldSerializeRemoteRender()
        {
            // remote-render
            return (RemoteRender != defRemoteRender);
        }

        private static ArenaVideoControlJson defVideoControl = null;
        [JsonProperty(PropertyName = "video-control")]
        [Tooltip("Adds a video to an entity and controls its playback.")]
        public ArenaVideoControlJson VideoControl = defVideoControl;
        public bool ShouldSerializeVideoControl()
        {
            // video-control
            return (VideoControl != defVideoControl);
        }

        private static ArenaAttributionJson defAttribution = null;
        [JsonProperty(PropertyName = "attribution")]
        [Tooltip("Attribution Component. Saves attribution data in any entity.")]
        public ArenaAttributionJson Attribution = defAttribution;
        public bool ShouldSerializeAttribution()
        {
            // attribution
            return (Attribution != defAttribution);
        }

        private static ArenaSpeParticlesJson defSpeParticles = null;
        [JsonProperty(PropertyName = "spe-particles")]
        [Tooltip("GPU based particle systems in A-Frame. More properties at <a href='https://github.com/harlyq/aframe-spe-particles-component'>A-Frame SPE Particles</a> component.")]
        public ArenaSpeParticlesJson SpeParticles = defSpeParticles;
        public bool ShouldSerializeSpeParticles()
        {
            // spe-particles
            return (SpeParticles != defSpeParticles);
        }

        private static string defLookAt = null;
        [JsonProperty(PropertyName = "look-at")]
        [Tooltip("The look-at component defines the behavior for an entity to dynamically rotate or face towards another entity or position. Use '#my-camera' to face the user camera, otherwise can take either a vec3 position or a query selector to another entity.")]
        public string LookAt = defLookAt;
        public bool ShouldSerializeLookAt()
        {
            // look-at
            return (LookAt != defLookAt);
        }

        private static bool defBuffer = true;
        [JsonProperty(PropertyName = "buffer")]
        [Tooltip("Transform geometry into a BufferGeometry to reduce memory usage at the cost of being harder to manipulate (geometries only: box, circle, cone, ...).")]
        public bool Buffer = defBuffer;
        public bool ShouldSerializeBuffer()
        {
            // buffer
            return (Buffer != defBuffer);
        }

        private static string defColor = null;
        [JsonProperty(PropertyName = "color")]
        [Obsolete("DEPRECATED: data.color is deprecated for primitive geometry, use data.material.color instead.")]
        public string Color { get; protected set; } = defColor;
        public bool ShouldSerializeColor()
        {
            return false; // deprecated in json schema
        }

        private static ArenaJitsiVideoJson defJitsiVideo = null;
        [JsonProperty(PropertyName = "jitsi-video")]
        [Tooltip("Apply a jitsi video source to the geometry.")]
        public ArenaJitsiVideoJson JitsiVideo = defJitsiVideo;
        public bool ShouldSerializeJitsiVideo()
        {
            // jitsi-video
            return (JitsiVideo != defJitsiVideo);
        }

        private static ArenaMaterialJson defMaterial = null;
        [JsonProperty(PropertyName = "material")]
        [Tooltip("The material properties of the object's surface. More properties at <a href='https://aframe.io/docs/1.5.0/components/material.html'>A-Frame Material</a>.")]
        public ArenaMaterialJson Material = defMaterial;
        public bool ShouldSerializeMaterial()
        {
            // material
            return (Material != defMaterial);
        }

        private static ArenaMultisrcJson defMultisrc = null;
        [JsonProperty(PropertyName = "multisrc")]
        [Tooltip("Define multiple visual sources applied to an object. Requires `material` attribute.")]
        public ArenaMultisrcJson Multisrc = defMultisrc;
        public bool ShouldSerializeMultisrc()
        {
            // multisrc
            return (Multisrc != defMultisrc);
        }

        private static bool defScreenshareable = true;
        [JsonProperty(PropertyName = "screenshareable")]
        [Tooltip("Whether or not a user can screenshare on an object.")]
        public bool Screenshareable = defScreenshareable;
        public bool ShouldSerializeScreenshareable()
        {
            // screenshareable
            return (Screenshareable != defScreenshareable);
        }

        private static bool defSkipCache = false;
        [JsonProperty(PropertyName = "skipCache")]
        [Tooltip("Disable retrieving the shared geometry object from the cache. (geometries only: box, circle, cone, ...).")]
        public bool SkipCache = defSkipCache;
        public bool ShouldSerializeSkipCache()
        {
            // skipCache
            return (SkipCache != defSkipCache);
        }

        private static ArenaAnimationMixerJson defAnimationMixer = null;
        [JsonProperty(PropertyName = "animation-mixer")]
        [Tooltip("A list of available animations can usually be found by inspecting the model file or its documentation. All animations will play by default. To play only a specific set of animations, use wildcards: animation-mixer='clip: run_*'. Requires `object_type: gltf-model`. More properties at <a href='https://github.com/n5ro/aframe-extras/tree/master/src/loaders#animation'>A-Frame Extras Animation</a>.")]
        public ArenaAnimationMixerJson AnimationMixer = defAnimationMixer;
        public bool ShouldSerializeAnimationMixer()
        {
            // animation-mixer
            return (AnimationMixer != defAnimationMixer);
        }

        private static ArenaGltfMorphJson defGltfMorph = null;
        [JsonProperty(PropertyName = "gltf-morph")]
        [Tooltip("Allows you to target and control a gltf model's morphTargets created in Blender. Requires `object_type: gltf-model`. More properties at <a href='https://github.com/elbobo/aframe-gltf-morph-component'>A-Frame GLTF Morph</a> component.")]
        public ArenaGltfMorphJson GltfMorph = defGltfMorph;
        public bool ShouldSerializeGltfMorph()
        {
            // gltf-morph
            return (GltfMorph != defGltfMorph);
        }

        private static ArenaGltfModelLodJson defGltfModelLod = null;
        [JsonProperty(PropertyName = "gltf-model-lod")]
        [Tooltip("Simple switch between the default gltf-model and a detailed one when a user camera is within specified distance. Requires `object_type: gltf-model`.")]
        public ArenaGltfModelLodJson GltfModelLod = defGltfModelLod;
        public bool ShouldSerializeGltfModelLod()
        {
            // gltf-model-lod
            return (GltfModelLod != defGltfModelLod);
        }

        private static ArenaModelUpdateJson defModelUpdate = null;
        [JsonProperty(PropertyName = "modelUpdate")]
        [Tooltip("The GLTF-specific `modelUpdate` attribute is an object with child component names as keys. The top-level keys are the names of the child components to be updated. The values of each are nested `position` and `rotation` attributes to set as new values, respectively. Either `position` or `rotation` can be omitted if unchanged. Requires `object_type: gltf-model`.")]
        public ArenaModelUpdateJson ModelUpdate = defModelUpdate;
        public bool ShouldSerializeModelUpdate()
        {
            // modelUpdate
            return (ModelUpdate != defModelUpdate);
        }

        private static ArenaArenaUserJson defArenaUser = null;
        [JsonProperty(PropertyName = "arena-user")]
        [Tooltip("The user avatar data for an ARENA user.")]
        public ArenaArenaUserJson ArenaUser = defArenaUser;
        public bool ShouldSerializeArenaUser()
        {
            return (ArenaUser != null);
        }

        private static object defGeometry = null;
        [JsonProperty(PropertyName = "geometry")]
        [Tooltip("The primitive mesh geometry.")]
        public object Geometry = defGeometry;
        public bool ShouldSerializeGeometry()
        {
            return (Geometry != null);
        }

        private static string defSrc = null;
        [JsonProperty(PropertyName = "src")]
        [Tooltip("A URL.")]
        public string Src = defSrc;
        public bool ShouldSerializeSrc()
        {
            return (Src != null);
        }

        private static object defLight = null;
        [JsonProperty(PropertyName = "light")]
        [Obsolete("DEPRECATED: data.light.[property] is deprecated, use object_type: light and data.[property] instead.")]
        public object Light { get; protected set; } = defLight;
        public bool ShouldSerializeLight()
        {
            return false; // deprecated in json schema
        }

        // General json object management
        [OnError]
        internal void OnError(StreamingContext context, ErrorContext errorContext)
        {
            Debug.LogWarning($"{errorContext.Error.Message}: {errorContext.OriginalObject}");
            errorContext.Handled = true;
        }

        [JsonExtensionData]
        private IDictionary<string, JToken> _additionalData;
    }
}
