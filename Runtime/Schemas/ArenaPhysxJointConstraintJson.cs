/**
 * Open source software under the terms in /LICENSE
 * Copyright (c) 2021-2024, Carnegie Mellon University. All rights reserved.
 */

// CAUTION: This file is autogenerated from https://github.com/arenaxr/arena-schemas. Changes made here may be overwritten.

using System;
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using UnityEngine;

namespace ArenaUnity.Schemas
{
    /// <summary>
    /// Adds a constraint to a physx-joint. Supported joints are D6, Revolute and Prismatic. Can only be used on an entity with the physx-joint component. Requires `scene-options: physics`.
    /// </summary>
    [Serializable]
    public class ArenaPhysxJointConstraintJson
    {
        [JsonIgnore]
        public readonly string componentName = "physx-joint-constraint";

        // physx-joint-constraint member-fields

        private static string[] defLockedAxes = {  };
        [JsonProperty(PropertyName = "lockedAxes")]
        [Tooltip("[D6] Which axes are explicitly locked by this constraint and can't be moved at all. Should be some combination of x, y, z, twist, swing.")]
        public string[] LockedAxes = defLockedAxes;
        public bool ShouldSerializeLockedAxes()
        {
            // lockedAxes
            return (LockedAxes != defLockedAxes);
        }

        private static string[] defConstrainedAxes = {  };
        [JsonProperty(PropertyName = "constrainedAxes")]
        [Tooltip("[D6] Which axes are constrained by this constraint. These axes can be moved within the set limits. Should be some combination of x, y, z, twist, swing.")]
        public string[] ConstrainedAxes = defConstrainedAxes;
        public bool ShouldSerializeConstrainedAxes()
        {
            // constrainedAxes
            return (ConstrainedAxes != defConstrainedAxes);
        }

        private static string[] defFreeAxes = {  };
        [JsonProperty(PropertyName = "freeAxes")]
        [Tooltip("[D6] Which axes are explicitly freed by this constraint. These axes will not obey any limits set here. Should be some combination of x, y, z, twist, swing.")]
        public string[] FreeAxes = defFreeAxes;
        public bool ShouldSerializeFreeAxes()
        {
            // freeAxes
            return (FreeAxes != defFreeAxes);
        }

        private static ArenaVector2Json defLinearLimit = null;
        [JsonProperty(PropertyName = "linearLimit")]
        [Tooltip("[D6, Prismatic] Limit on linear movement. Only affects x, y, and z axes. First component is the minimum allowed position.")]
        public ArenaVector2Json LinearLimit = defLinearLimit;
        public bool ShouldSerializeLinearLimit()
        {
            // linearLimit
            return (LinearLimit != defLinearLimit);
        }

        private static ArenaVector2Json defAngularLimit = null;
        [JsonProperty(PropertyName = "angularLimit")]
        [Tooltip("[Revolute] Limit on angular movement in degrees. First component is the minimum allowed angle, second is the maximum.")]
        public ArenaVector2Json AngularLimit = defAngularLimit;
        public bool ShouldSerializeAngularLimit()
        {
            // angularLimit
            return (AngularLimit != defAngularLimit);
        }

        private static ArenaVector2Json defLimitCone = null;
        [JsonProperty(PropertyName = "limitCone")]
        [Tooltip("[D6] Two angles in degrees specifying a cone in which the joint is allowed to swing, like a pendulum.")]
        public ArenaVector2Json LimitCone = defLimitCone;
        public bool ShouldSerializeLimitCone()
        {
            // limitCone
            return (LimitCone != defLimitCone);
        }

        private static ArenaVector2Json defTwistLimit = null;
        [JsonProperty(PropertyName = "twistLimit")]
        [Tooltip("[D6] Minimum and maximum angles in degrees that the joint is allowed to twist.")]
        public ArenaVector2Json TwistLimit = defTwistLimit;
        public bool ShouldSerializeTwistLimit()
        {
            // twistLimit
            return (TwistLimit != defTwistLimit);
        }

        private static float defDamping = 0f;
        [JsonProperty(PropertyName = "damping")]
        [Tooltip("[All] Spring damping for soft constraints.")]
        public float Damping = defDamping;
        public bool ShouldSerializeDamping()
        {
            // damping
            return (Damping != defDamping);
        }

        private static float defRestitution = 0f;
        [JsonProperty(PropertyName = "restitution")]
        [Tooltip("[All] Spring restitution for soft constraints.")]
        public float Restitution = defRestitution;
        public bool ShouldSerializeRestitution()
        {
            // restitution
            return (Restitution != defRestitution);
        }

        private static float defStiffness = 0f;
        [JsonProperty(PropertyName = "stiffness")]
        [Tooltip("[All] If greater than 0, will make this joint a soft constraint, and use a spring force model.")]
        public float Stiffness = defStiffness;
        public bool ShouldSerializeStiffness()
        {
            // stiffness
            return (Stiffness != defStiffness);
        }

        // General json object management
        [OnError]
        internal void OnError(StreamingContext context, ErrorContext errorContext)
        {
            Debug.LogWarning($"{errorContext.Error.Message}: {errorContext.OriginalObject}");
            errorContext.Handled = true;
        }

        [JsonExtensionData]
        private IDictionary<string, JToken> _additionalData;
    }
}
