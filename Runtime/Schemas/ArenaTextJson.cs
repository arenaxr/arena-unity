/**
 * Open source software under the terms in /LICENSE
 * Copyright (c) 2021-2024, Carnegie Mellon University. All rights reserved.
 */

// CAUTION: This file is autogenerated from https://github.com/arenaxr/arena-schemas. Changes made here may be overwritten.

using System;
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using UnityEngine;

namespace ArenaUnity.Schemas
{
    /// <summary>
    /// Display text. More properties at <a href='https://aframe.io/docs/1.5.0/components/text.html'>A-Frame Text</a>.
    /// </summary>
    [Serializable]
    public class ArenaTextJson
    {
        public readonly string object_type = "text";

        // text member-fields

        public enum AlignType
        {
            [EnumMember(Value = "left")]
            Left,
            [EnumMember(Value = "center")]
            Center,
            [EnumMember(Value = "right")]
            Right,
        }
        private static AlignType defAlign = AlignType.Left;
        [JsonConverter(typeof(StringEnumConverter))]
        [JsonProperty(PropertyName = "align")]
        [Tooltip("Multi-line text alignment.")]
        public AlignType Align = defAlign;
        public bool ShouldSerializeAlign()
        {
            // align
            return (Align != defAlign);
        }

        private static float defAlphaTest = 0.5f;
        [JsonProperty(PropertyName = "alphaTest")]
        [Tooltip("Discard text pixels if alpha is less than this value.")]
        public float AlphaTest = defAlphaTest;
        public bool ShouldSerializeAlphaTest()
        {
            // alphaTest
            return (AlphaTest != defAlphaTest);
        }

        public enum AnchorType
        {
            [EnumMember(Value = "left")]
            Left,
            [EnumMember(Value = "right")]
            Right,
            [EnumMember(Value = "center")]
            Center,
            [EnumMember(Value = "align")]
            Align,
        }
        private static AnchorType defAnchor = AnchorType.Center;
        [JsonConverter(typeof(StringEnumConverter))]
        [JsonProperty(PropertyName = "anchor")]
        [Tooltip("Horizontal positioning.")]
        public AnchorType Anchor = defAnchor;
        public bool ShouldSerializeAnchor()
        {
            // anchor
            return (Anchor != defAnchor);
        }

        public enum BaselineType
        {
            [EnumMember(Value = "top")]
            Top,
            [EnumMember(Value = "center")]
            Center,
            [EnumMember(Value = "bottom")]
            Bottom,
        }
        private static BaselineType defBaseline = BaselineType.Center;
        [JsonConverter(typeof(StringEnumConverter))]
        [JsonProperty(PropertyName = "baseline")]
        [Tooltip("Vertical positioning.")]
        public BaselineType Baseline = defBaseline;
        public bool ShouldSerializeBaseline()
        {
            // baseline
            return (Baseline != defBaseline);
        }

        private static string defColor = "#000000";
        [JsonProperty(PropertyName = "color")]
        [Tooltip("Text color.")]
        public string Color = defColor;
        public bool ShouldSerializeColor()
        {
            return true; // required in json schema
        }

        public enum FontType
        {
            [EnumMember(Value = "aileronsemibold")]
            Aileronsemibold,
            [EnumMember(Value = "dejavu")]
            Dejavu,
            [EnumMember(Value = "exo2bold")]
            Exo2bold,
            [EnumMember(Value = "exo2semibold")]
            Exo2semibold,
            [EnumMember(Value = "kelsonsans")]
            Kelsonsans,
            [EnumMember(Value = "monoid")]
            Monoid,
            [EnumMember(Value = "mozillavr")]
            Mozillavr,
            [EnumMember(Value = "roboto")]
            Roboto,
            [EnumMember(Value = "sourcecodepro")]
            Sourcecodepro,
        }
        private static FontType defFont = FontType.Roboto;
        [JsonConverter(typeof(StringEnumConverter))]
        [JsonProperty(PropertyName = "font")]
        [Tooltip("Font to render text, either the name of one of A-Frame's stock fonts or a URL to a font file.")]
        public FontType Font = defFont;
        public bool ShouldSerializeFont()
        {
            return true; // required in json schema
        }

        private static string defFontImage = null;
        [JsonProperty(PropertyName = "fontImage")]
        [Tooltip("Font image texture path to render text. Defaults to the font's name with extension replaced to .png. Don't need to specify if using a stock font. (derived from font name).")]
        public string FontImage = defFontImage;
        public bool ShouldSerializeFontImage()
        {
            // fontImage
            return (FontImage != defFontImage);
        }

        private static float? defHeight = null;
        [JsonProperty(PropertyName = "height")]
        [Tooltip("Height of text block. (derived from text size).")]
        public float? Height = defHeight;
        public bool ShouldSerializeHeight()
        {
            // height
            return (Height != defHeight);
        }

        private static float defLetterSpacing = 0f;
        [JsonProperty(PropertyName = "letterSpacing")]
        [Tooltip("Letter spacing in pixels.")]
        public float LetterSpacing = defLetterSpacing;
        public bool ShouldSerializeLetterSpacing()
        {
            // letterSpacing
            return (LetterSpacing != defLetterSpacing);
        }

        private static float? defLineHeight = null;
        [JsonProperty(PropertyName = "lineHeight")]
        [Tooltip("Line height in pixels. (derived from font file).")]
        public float? LineHeight = defLineHeight;
        public bool ShouldSerializeLineHeight()
        {
            // lineHeight
            return (LineHeight != defLineHeight);
        }

        private static float defOpacity = 1f;
        [JsonProperty(PropertyName = "opacity")]
        [Tooltip("Opacity, on a scale from 0 to 1, where 0 means fully transparent and 1 means fully opaque.")]
        public float Opacity = defOpacity;
        public bool ShouldSerializeOpacity()
        {
            // opacity
            return (Opacity != defOpacity);
        }

        public enum ShaderType
        {
            [EnumMember(Value = "portal")]
            Portal,
            [EnumMember(Value = "flat")]
            Flat,
            [EnumMember(Value = "standard")]
            Standard,
            [EnumMember(Value = "sdf")]
            Sdf,
            [EnumMember(Value = "msdf")]
            Msdf,
            [EnumMember(Value = "ios10hls")]
            Ios10hls,
            [EnumMember(Value = "skyshader")]
            Skyshader,
            [EnumMember(Value = "gradientshader")]
            Gradientshader,
        }
        private static ShaderType defShader = ShaderType.Sdf;
        [JsonConverter(typeof(StringEnumConverter))]
        [JsonProperty(PropertyName = "shader")]
        [Tooltip("Shader used to render text.")]
        public ShaderType Shader = defShader;
        public bool ShouldSerializeShader()
        {
            // shader
            return (Shader != defShader);
        }

        public enum SideType
        {
            [EnumMember(Value = "front")]
            Front,
            [EnumMember(Value = "back")]
            Back,
            [EnumMember(Value = "double")]
            Double,
        }
        private static SideType defSide = SideType.Double;
        [JsonConverter(typeof(StringEnumConverter))]
        [JsonProperty(PropertyName = "side")]
        [Tooltip("Side to render.")]
        public SideType Side = defSide;
        public bool ShouldSerializeSide()
        {
            return true; // required in json schema
        }

        private static float defTabSize = 4f;
        [JsonProperty(PropertyName = "tabSize")]
        [Tooltip("Tab size in spaces.")]
        public float TabSize = defTabSize;
        public bool ShouldSerializeTabSize()
        {
            // tabSize
            return (TabSize != defTabSize);
        }

        private static string defText = null;
        [JsonProperty(PropertyName = "text")]
        [Tooltip("DEPRECATED: data.text is deprecated for object_type: text, use data.value instead.")]
        public string Text = defText;
        public bool ShouldSerializeText()
        {
            return false; // deprecated in json schema
        }

        private static bool defTransparent = true;
        [JsonProperty(PropertyName = "transparent")]
        [Tooltip("Whether text is transparent.")]
        public bool Transparent = defTransparent;
        public bool ShouldSerializeTransparent()
        {
            // transparent
            return (Transparent != defTransparent);
        }

        private static string defValue = null;
        [JsonProperty(PropertyName = "value")]
        [Tooltip("The actual content of the text. Line breaks and tabs are supported with `\n` and `\t`.")]
        public string Value = defValue;
        public bool ShouldSerializeValue()
        {
            return true; // required in json schema
        }

        public enum WhiteSpaceType
        {
            [EnumMember(Value = "normal")]
            Normal,
            [EnumMember(Value = "pre")]
            Pre,
            [EnumMember(Value = "nowrap")]
            Nowrap,
        }
        private static WhiteSpaceType defWhiteSpace = WhiteSpaceType.Normal;
        [JsonConverter(typeof(StringEnumConverter))]
        [JsonProperty(PropertyName = "whiteSpace")]
        [Tooltip("How whitespace should be handled.")]
        public WhiteSpaceType WhiteSpace = defWhiteSpace;
        public bool ShouldSerializeWhiteSpace()
        {
            // whiteSpace
            return (WhiteSpace != defWhiteSpace);
        }

        private static float defWidth = 5f;
        [JsonProperty(PropertyName = "width")]
        [Tooltip("Width in meters. (derived from geometry if exists).")]
        public float Width = defWidth;
        public bool ShouldSerializeWidth()
        {
            // width
            return (Width != defWidth);
        }

        private static float defWrapCount = 40f;
        [JsonProperty(PropertyName = "wrapCount")]
        [Tooltip("Number of characters before wrapping text (more or less).")]
        public float WrapCount = defWrapCount;
        public bool ShouldSerializeWrapCount()
        {
            // wrapCount
            return (WrapCount != defWrapCount);
        }

        private static float? defWrapPixels = null;
        [JsonProperty(PropertyName = "wrapPixels")]
        [Tooltip("Number of pixels before wrapping text. (derived from wrapCount).")]
        public float? WrapPixels = defWrapPixels;
        public bool ShouldSerializeWrapPixels()
        {
            // wrapPixels
            return (WrapPixels != defWrapPixels);
        }

        private static float defXoffset = 0f;
        [JsonProperty(PropertyName = "xOffset")]
        [Tooltip("X-offset to apply to add padding.")]
        public float Xoffset = defXoffset;
        public bool ShouldSerializeXoffset()
        {
            // xOffset
            return (Xoffset != defXoffset);
        }

        private static float defZoffset = 0.001f;
        [JsonProperty(PropertyName = "zOffset")]
        [Tooltip("Z-offset to apply to avoid Z-fighting if using with a geometry as a background.")]
        public float Zoffset = defZoffset;
        public bool ShouldSerializeZoffset()
        {
            // zOffset
            return (Zoffset != defZoffset);
        }

        // General json object management
        [OnError]
        internal void OnError(StreamingContext context, ErrorContext errorContext)
        {
            Debug.LogWarning($"{errorContext.Error.Message}: {errorContext.OriginalObject}");
            errorContext.Handled = true;
        }

        [JsonExtensionData]
        private IDictionary<string, JToken> _additionalData;
    }
}
