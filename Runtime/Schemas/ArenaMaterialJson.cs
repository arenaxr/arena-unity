/**
 * Open source software under the terms in /LICENSE
 * Copyright (c) 2021-2024, Carnegie Mellon University. All rights reserved.
 */

// CAUTION: This file is autogenerated from https://github.com/arenaxr/arena-schemas. Changes made here may be overwritten.

using System;
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using UnityEngine;

namespace ArenaUnity.Schemas
{
    /// <summary>
    /// The material properties of the object's surface. More properties at <a href='https://aframe.io/docs/1.5.0/components/material.html'>A-Frame Material</a>.
    /// </summary>
    [Serializable]
    public class ArenaMaterialJson
    {
        [JsonIgnore]
        public readonly string componentName = "material";

        // material member-fields

        private static float defAlphaTest = 0f;
        [JsonProperty(PropertyName = "alphaTest")]
        [Tooltip("Alpha test threshold for transparency.")]
        public float AlphaTest = defAlphaTest;
        public bool ShouldSerializeAlphaTest()
        {
            // alphaTest
            return (AlphaTest != defAlphaTest);
        }

        private static float defAnisotropy = 0f;
        [JsonProperty(PropertyName = "anisotropy")]
        [Tooltip("The anisotropic filtering sample rate to use for the textures. A value of 0 means the default value will be used, see renderer.")]
        public float Anisotropy = defAnisotropy;
        public bool ShouldSerializeAnisotropy()
        {
            // anisotropy
            return (Anisotropy != defAnisotropy);
        }

        public enum BlendingType
        {
            [EnumMember(Value = "none")]
            None,
            [EnumMember(Value = "normal")]
            Normal,
            [EnumMember(Value = "additive")]
            Additive,
            [EnumMember(Value = "subtractive")]
            Subtractive,
            [EnumMember(Value = "multiply")]
            Multiply,
        }
        private static BlendingType defBlending = BlendingType.Normal;
        [JsonConverter(typeof(StringEnumConverter))]
        [JsonProperty(PropertyName = "blending")]
        [Tooltip("The blending mode for the material's RGB and Alpha sent to the WebGLRenderer.")]
        public BlendingType Blending = defBlending;
        public bool ShouldSerializeBlending()
        {
            // blending
            return (Blending != defBlending);
        }

        private static string defColor = "#ffffff";
        [JsonProperty(PropertyName = "color")]
        [Tooltip("Base diffuse color.")]
        public string Color = defColor;
        public bool ShouldSerializeColor()
        {
            // color
            return (Color != defColor);
        }

        public enum CombineType
        {
            [EnumMember(Value = "mix")]
            Mix,
            [EnumMember(Value = "add")]
            Add,
            [EnumMember(Value = "multiply")]
            Multiply,
        }
        private static CombineType defCombine = CombineType.Mix;
        [JsonConverter(typeof(StringEnumConverter))]
        [JsonProperty(PropertyName = "combine")]
        [Tooltip("How the environment map mixes with the material. Requires shader: phong.")]
        public CombineType Combine = defCombine;
        public bool ShouldSerializeCombine()
        {
            // combine
            return (Combine != defCombine);
        }

        private static bool defDepthTest = true;
        [JsonProperty(PropertyName = "depthTest")]
        [Tooltip("Whether depth testing is enabled when rendering the material.")]
        public bool DepthTest = defDepthTest;
        public bool ShouldSerializeDepthTest()
        {
            // depthTest
            return (DepthTest != defDepthTest);
        }

        private static bool defDepthWrite = true;
        [JsonProperty(PropertyName = "depthWrite")]
        [Tooltip("Render when depth test succeeds.")]
        public bool DepthWrite = defDepthWrite;
        public bool ShouldSerializeDepthWrite()
        {
            // depthWrite
            return (DepthWrite != defDepthWrite);
        }

        private static bool defDithering = true;
        [JsonProperty(PropertyName = "dithering")]
        [Tooltip("Whether material is dithered with noise. Removes banding from gradients like ones produced by lighting.")]
        public bool Dithering = defDithering;
        public bool ShouldSerializeDithering()
        {
            // dithering
            return (Dithering != defDithering);
        }

        private static string defEmissive = "#000000";
        [JsonProperty(PropertyName = "emissive")]
        [Tooltip("The color of the emissive lighting component. Used to make objects produce light even without other lighting in the scene. Requires shader: standard or phong")]
        public string Emissive = defEmissive;
        public bool ShouldSerializeEmissive()
        {
            // emissive
            return (Emissive != defEmissive);
        }

        private static float defEmissiveIntensity = 1f;
        [JsonProperty(PropertyName = "emissiveIntensity")]
        [Tooltip("Intensity of the emissive lighting component. Requires shader: standard or phong")]
        public float EmissiveIntensity = defEmissiveIntensity;
        public bool ShouldSerializeEmissiveIntensity()
        {
            // emissiveIntensity
            return (EmissiveIntensity != defEmissiveIntensity);
        }

        private static bool defFlatShading = false;
        [JsonProperty(PropertyName = "flatShading")]
        [Tooltip("Use THREE.FlatShading rather than THREE.StandardShading.")]
        public bool FlatShading = defFlatShading;
        public bool ShouldSerializeFlatShading()
        {
            // flatShading
            return (FlatShading != defFlatShading);
        }

        private static bool defFog = true;
        [JsonProperty(PropertyName = "fog")]
        [Tooltip("Whether or not material is affected by fog.")]
        public bool Fog = defFog;
        public bool ShouldSerializeFog()
        {
            // fog
            return (Fog != defFog);
        }

        private static int defHeight = 256;
        [JsonProperty(PropertyName = "height")]
        [Tooltip("Height of video (in pixels), if defining a video texture. Requires shader: standard or flat.")]
        public int Height = defHeight;
        public bool ShouldSerializeHeight()
        {
            // height
            return (Height != defHeight);
        }

        private static float defMetalness = 0f;
        [JsonProperty(PropertyName = "metalness")]
        [Tooltip("How metallic the material is from 0 to 1. Requires shader: standard.")]
        public float Metalness = defMetalness;
        public bool ShouldSerializeMetalness()
        {
            // metalness
            return (Metalness != defMetalness);
        }

        private static bool defNpot = false;
        [JsonProperty(PropertyName = "npot")]
        [Tooltip("Use settings for non-power-of-two (NPOT) texture.")]
        public bool Npot = defNpot;
        public bool ShouldSerializeNpot()
        {
            // npot
            return (Npot != defNpot);
        }

        private static object defOffset = JsonConvert.DeserializeObject("{'x': 0, 'y': 0}");
        [JsonProperty(PropertyName = "offset")]
        [Tooltip("Texture offset to be used.")]
        public object Offset = defOffset;
        public bool ShouldSerializeOffset()
        {
            // offset
            return (Offset != defOffset);
        }

        private static float defOpacity = 1f;
        [JsonProperty(PropertyName = "opacity")]
        [Tooltip("Extent of transparency. If the transparent property is not true, then the material will remain opaque and opacity will only affect color.")]
        public float Opacity = defOpacity;
        public bool ShouldSerializeOpacity()
        {
            // opacity
            return (Opacity != defOpacity);
        }

        private static float defReflectivity = 0.9f;
        [JsonProperty(PropertyName = "reflectivity")]
        [Tooltip("How much the environment map affects the surface. Requires shader: phong.")]
        public float Reflectivity = defReflectivity;
        public bool ShouldSerializeReflectivity()
        {
            // reflectivity
            return (Reflectivity != defReflectivity);
        }

        private static bool defRefract = false;
        [JsonProperty(PropertyName = "refract")]
        [Tooltip("Whether the defined envMap should refract. Requires shader: phong.")]
        public bool Refract = defRefract;
        public bool ShouldSerializeRefract()
        {
            // refract
            return (Refract != defRefract);
        }

        private static float defRefractionRatio = 0.98f;
        [JsonProperty(PropertyName = "refractionRatio")]
        [Tooltip("1/refractive index of the material. Requires shader: phong.")]
        public float RefractionRatio = defRefractionRatio;
        public bool ShouldSerializeRefractionRatio()
        {
            // refractionRatio
            return (RefractionRatio != defRefractionRatio);
        }

        private static object defRepeat = JsonConvert.DeserializeObject("{'x': 1, 'y': 1}");
        [JsonProperty(PropertyName = "repeat")]
        [Tooltip("How many times a texture (defined by src) repeats in the X and Y direction.")]
        public object Repeat = defRepeat;
        public bool ShouldSerializeRepeat()
        {
            // repeat
            return (Repeat != defRepeat);
        }

        private static float defRoughness = 0f;
        [JsonProperty(PropertyName = "roughness")]
        [Tooltip("How rough the material is from 0 to 1. A rougher material will scatter reflected light in more directions than a smooth material. Requires shader: standard.")]
        public float Roughness = defRoughness;
        public bool ShouldSerializeRoughness()
        {
            // roughness
            return (Roughness != defRoughness);
        }

        public enum ShaderType
        {
            [EnumMember(Value = "flat")]
            Flat,
            [EnumMember(Value = "standard")]
            Standard,
            [EnumMember(Value = "phong")]
            Phong,
        }
        private static ShaderType defShader = ShaderType.Standard;
        [JsonConverter(typeof(StringEnumConverter))]
        [JsonProperty(PropertyName = "shader")]
        [Tooltip("Which material to use. Defaults to the standard material. Can be set to the flat material or to a registered custom shader material.")]
        public ShaderType Shader = defShader;
        public bool ShouldSerializeShader()
        {
            // shader
            return (Shader != defShader);
        }

        private static float defShininess = 30f;
        [JsonProperty(PropertyName = "shininess")]
        [Tooltip("How shiny the specular highlight is; a higher value gives a sharper highlight. Requires shader: phong.")]
        public float Shininess = defShininess;
        public bool ShouldSerializeShininess()
        {
            // shininess
            return (Shininess != defShininess);
        }

        public enum SideType
        {
            [EnumMember(Value = "front")]
            Front,
            [EnumMember(Value = "back")]
            Back,
            [EnumMember(Value = "double")]
            Double,
        }
        private static SideType defSide = SideType.Front;
        [JsonConverter(typeof(StringEnumConverter))]
        [JsonProperty(PropertyName = "side")]
        [Tooltip("Which sides of the mesh to render.")]
        public SideType Side = defSide;
        public bool ShouldSerializeSide()
        {
            // side
            return (Side != defSide);
        }

        private static string defSpecular = "#111111";
        [JsonProperty(PropertyName = "specular")]
        [Tooltip("This defines how shiny the material is and the color of its shine. Requires shader: phong.")]
        public string Specular = defSpecular;
        public bool ShouldSerializeSpecular()
        {
            // specular
            return (Specular != defSpecular);
        }

        private static string defSrc = null;
        [JsonProperty(PropertyName = "src")]
        [Tooltip("URI, relative or full path of an image/video file. e.g. 'store/users/wiselab/images/360falls.mp4'.")]
        public string Src = defSrc;
        public bool ShouldSerializeSrc()
        {
            // src
            return (Src != defSrc);
        }

        private static bool defToneMapped = true;
        [JsonProperty(PropertyName = "toneMapped")]
        [Tooltip("Whether to ignore toneMapping, set to false you are using renderer.toneMapping and an element should appear to emit light. Requires shader: flat.")]
        public bool ToneMapped = defToneMapped;
        public bool ShouldSerializeToneMapped()
        {
            // toneMapped
            return (ToneMapped != defToneMapped);
        }

        private static bool defTransparent = false;
        [JsonProperty(PropertyName = "transparent")]
        [Tooltip("Whether material is transparent. Transparent entities are rendered after non-transparent entities.")]
        public bool Transparent = defTransparent;
        public bool ShouldSerializeTransparent()
        {
            // transparent
            return (Transparent != defTransparent);
        }

        private static bool defVertexColorsEnabled = false;
        [JsonProperty(PropertyName = "vertexColorsEnabled")]
        [Tooltip("Whether to use vertex or face colors to shade the material.")]
        public bool VertexColorsEnabled = defVertexColorsEnabled;
        public bool ShouldSerializeVertexColorsEnabled()
        {
            // vertexColorsEnabled
            return (VertexColorsEnabled != defVertexColorsEnabled);
        }

        private static bool defVisible = true;
        [JsonProperty(PropertyName = "visible")]
        [Tooltip("Whether material is visible. Raycasters will ignore invisible materials.")]
        public bool Visible = defVisible;
        public bool ShouldSerializeVisible()
        {
            // visible
            return (Visible != defVisible);
        }

        private static int defWidth = 512;
        [JsonProperty(PropertyName = "width")]
        [Tooltip("Width of video (in pixels), if defining a video texture. Requires shader: standard or flat.")]
        public int Width = defWidth;
        public bool ShouldSerializeWidth()
        {
            // width
            return (Width != defWidth);
        }

        private static bool defWireframe = false;
        [JsonProperty(PropertyName = "wireframe")]
        [Tooltip("Whether to render just the geometry edges.")]
        public bool Wireframe = defWireframe;
        public bool ShouldSerializeWireframe()
        {
            // wireframe
            return (Wireframe != defWireframe);
        }

        private static int defWireframeLinewidth = 2;
        [JsonProperty(PropertyName = "wireframeLinewidth")]
        [Tooltip("Width in px of the rendered line.")]
        public int WireframeLinewidth = defWireframeLinewidth;
        public bool ShouldSerializeWireframeLinewidth()
        {
            // wireframeLinewidth
            return (WireframeLinewidth != defWireframeLinewidth);
        }

        // General json object management
        [OnError]
        internal void OnError(StreamingContext context, ErrorContext errorContext)
        {
            Debug.LogWarning($"{errorContext.Error.Message}: {errorContext.OriginalObject}");
            errorContext.Handled = true;
        }

        [JsonExtensionData]
        private IDictionary<string, JToken> _additionalData;
    }
}
